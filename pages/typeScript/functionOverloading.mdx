# Function Overloading

Function Overloading pozwala na zdefiniowanie wielu funkcji o tej samej nazwie, ale z r贸偶nymi parametrami. Funkcja wywoywana jest na podstawie przekazanych parametr贸w.

## Definiowanie

```js filename="overloading.ts" copy
function foo(arg1: string, arg2: string): string[];
function foo(arg1: number, arg2: number): number;

function foo(arg1: any, arg2: any): any {
  if (typeof arg1 === "string") return [arg1, arg2];
  return arg1 + arg2;
}
```

import { Callout } from "nextra/components";

<Callout emoji="">
  Warto zwr贸ci uwag, 偶e nie trzeba sprawdza czy **`typeof arg2 === string`**,
  poniewa偶 jeli **`arg1`** jest stringiem, to **`arg2`** te偶 musi by stringiem
  i TS to wie.
</Callout>
;

## Wywoywanie

```js filename="overloading.ts" copy
const one = foo("a", "b");
// zwraca ['a', 'b'], one: string[]
const two = foo(1, 2);
// zwraca 3, two: number
const three = foo("a", 10);
// error: No overload matches this call.
```

## Alternatywa

Alternatyw dla overloadingu jest u偶ycie typ贸w warunkowych. W tym przypadku TS r贸wnie偶 wie jakiego typu jest zwracana warto, wie r贸wnie偶 jakiego typu powinny by parametry, ale sama konstrukcja takiej funkcji jest mniej elegancka.

```js filename="overloading.ts" copy
type ConditionalType<T> = T extends string ? string[] : number;

function bar<T extends string | number>(arg1: T, arg2: T): ConditionalType<T> {
  if (typeof arg1 === "string") {
    return [arg1, arg2] as ConditionalType<T>;
  }
  if (typeof arg1 === "number") {
    return (arg1 + arg2) as ConditionalType<T>;
  }
}

const one = bar("a", "b");
// zwraca ['a', 'b'], one: string[]
const two = bar(1, 2);
// zwraca 3, two: number
const three = bar("a", 10);
// type error: Argument of type '10' is not assignable to parameter of type '"a"'
```

## Przykad

Stw贸rzmy funkcj, kt贸ra pozwala manipulowa dwoma typami argument贸w w taki spos贸b, aby zachowa typy zwracane przez funkcj.

```js filename="overloading.ts" copy
import { useRouter } from "next/router";

const router = useRouter();
const query = router.query.myQuery;
// query: string | string[]

function manipulateQuery(query: string): string
function manipulateQuery(query: string[]): string[]
function manipulateQuery(query: string | string[]): string | string[]

function manipulateQuery(query: any): any {
  if (typeof query === "string") return query.toUpperCase();
  return query.map((querry) => querry.toUpperCase());
}

const manipulatedQuery = manipulateQuery(query);
// manipulatedQuery: string | string[]
const manipulatedQuery2 = manipulateQuery("foo");
// manipulatedQuery2: string
const manipulatedQuery3 = manipulateQuery(["foo", "bar"]);
// manipulatedQuery3: string[]
```

<Callout emoji="">
  W tym przypadku mo偶emy zaobserwowa, 偶e jeli przekazany argument jest
  dowolnym z dwu mo偶liwych typ贸w, to TS oczekuje, 偶e zwr贸cona warto bdzie
  dowolnym z dwu mo偶liwych typ贸w. Jeli natomiast posu偶ymy si argumentem o
  konkretnym typie, to TS bdzie wiedzia, 偶e zwr贸cona warto bdzie miaa ten
  sam typ.
</Callout>
